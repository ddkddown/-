##死锁
若线程A已经lock了锁1后，想要继续lock锁2，而同时线程B已经lock了锁2，并且也想继续lock锁1。
此时就造成了死锁问题。
###解决方法：
1. 创建统一的加锁方式:如创建一个加锁函数
```
bool LockHierarchy() {
  Lock(mutex_1);
  Lock(mutex_2);
}
```

2. 回滚:若线程A尝试lock锁2失败后，将先释放自己已经拥有的锁
```
if(!TryLock(mutex_2)) {
  UnLock(mutex_1);
}
```

##lock chain
当多线程需要串行进入临界区，且对临界区的不同部分有不同修改时，可以使用lock chain
```
void LockChain() {
  Lock(mutex_1);
  //do_something
  UnLock(mutex_1);
  
  Lock(mutex_2);
  //do_something
  UnLock(mutex_2);
  
  ......
}
```

##类对象中包含锁成员的问题
```
class test{
private:
  mutex m;
public:
  void func(){
    m.lock();
    ......
   }
}

main (){
  ......
  test tmp;
  thread(thread2);
  ......
}

thread2 (){
......
tmp.func();
......
}
```
如上述代码所示，若一个test实例同时被两个线程访问，当实例析构时，这个时候锁成员也会被析构，而可能此时在另一个线程内正在执行m.lock()这一步，但同时因为实例已经被析构了，锁成员也不存在了。
所以，这时在另一个线程里调用m.lock()会造成无法预知的结果，（可能是永远阻塞，也可能是coredump。。。。)

解决方法可以用shared_ptr,因为shared_ptr/weak_ptr的计数在主流平台上是原子操作（仅仅引用计数是线程安全的，但是绑定的对象不是）。

```
class test{
public:
  shared_ptr<Mutex> m = make_shared<...>
public:
  void func(){
    m.lock();
    ......
   }
}

class Observable
{
public:
  weak_ptr<test> w;
}
main (){
  ......
  test tmp;
  thread(thread2);
  ......
}

thread2 (){
Observable o;
o.w = tmp.m;
......
weak_ptr<Mutex> w = tmp.m;
if(!w->lock())
{
  //tmp没有被析构
  tmp.func();
}
......
}
```

##虚假唤醒
在编写条件变量程序，等待时，应该这样写
```
m.lock()
while(queue.empty())
{
  cond.wait() //条件变量的wait，会释放锁然后进行等待，这一步是原子性的，收到信号后又会获得锁，所以之后还需要程序员进行释放。
}
m.unlock()
```

如果用if判断则会有虚假唤醒的问题（signal的时候唤醒了多余的线程），所以需要用while，即使被虚假唤醒了，线程还是会获得锁，然后再进行判断，再进行等待。

